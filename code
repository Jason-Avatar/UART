
///////////////////////
/*
using UTF-8
石英晶體頻率11.0592MHz,鮑率9600BPS
9600BPS代表1秒船9600個bit的資料
所以1bit的資料花(1/9600)秒=104us
指令週期(us)=石英晶體頻率(MHz)/12=11.0592/12=1.08507(us)
故傳1bit的資料花104/1.08507=96個指令週期
*/
///////////////////////	
#include <AT89X51.H>
char c[10]={0,0,0,0,0,0,0,1,0,1};
int n=0;

main()
{
	
  P1_0=1;
  TMOD=0x01;
  TH0=(65536-0)/256;//-0代表計時0個指令週期,所以就是立即執行中斷(因為開頭1→0,沒有時間間隔限制(輸出0後才開始在間隔時間後取值拿資料))
  TL0=(65536-0)%256;
  EA=1;
  ET0=1;
  TR0=1;
  while(1);
}


void timer0_int(void) interrupt 1
{
	/*
	此處不能在加指令,因為計時時間已到,所以必須立刻發送P1_0=C[n],否則就要再減少75這個值
	*/
	P1_0=c[n];
 	TH0=(65536-75)/256;//65536-75相當於計時75個指令週期,理論上應該是65536-96但考量到執行P1_0=c[i]指令本身需要時間,經測試後發現,用75的間隔時間最接近104us,總之間隔指令執行時間+計時時間要等於104us)
  TL0=(65536-75)%256;
	n++;
	/*
	THO,TLO後面加指令不會影響到總執行時間,因為執行時計時器也在同時計時
	P1_2=c[n];
	P1_3=0;
	   .
	   .
	   .
	*/
	if(n==10)
		while(1);
}
 
